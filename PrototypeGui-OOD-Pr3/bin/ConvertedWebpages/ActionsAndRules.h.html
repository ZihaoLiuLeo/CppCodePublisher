<DOCTYPE !HTML>
<html>
  <head>
    <Title>AbstrSynTree.h</Title>
    <script src="script.js"></script>
    <link rel="stylesheet" type="text/css" href="style.css">
  </head>

  <body>
    <span class="absolute">
      <label><input type="checkbox" id ="hideF" value="hidefuncs" checked="true" onclick="toggleVisibility('function')">Functions</label><br>
      <label><input type="checkbox" id ="hideC" value="hideclass" checked="true" onclick="toggleVisibility('class')">Classes</label><br>
      <label><input type="checkbox" id ="hidec" value="hidecomms" checked="true" onclick="toggleVisibility('comment')">Comments</label><br>
    </span>
    <h3>Dependencies: 
      <a href=".html"></a>
      <a href="AbstrSynTree.cpp.html">AbstrSynTree.cpp</a>
    </h3>    <pre>
#pragma once
<span class="comment">/////////////////////////////////////////////////////////////////////
//  AbstrSynTree.h - Represents an Abstract Syntax Tree            //
//  ver 1.5                                                        //
//  Language:      Visual C++ 2015                                 //
//  Platform:      Dell XPS 8900, Windows 10                       //
//  Application:   Used to support parsing source code             //
//  Author:        Jim Fawcett, CST 4-187, Syracuse University     //
//                 (315) 443-3948, jfawcett@twcny.rr.com           //
/////////////////////////////////////////////////////////////////////</span>
<span class="comment">/*
  Package Operations:
  ==================
  This package defines an AbstrSynTree class and an ASTNode struct.  
  Those provides support for building Abstract Syntax Trees during 
  static source code analysis.

  Public Interface:
  =================
  AbstrSynTree ast(scopeStack);       <span class="comment">// create instance, passing in ScopeStack</span>
  ASTNode* pNode = ast.root();        <span class="comment">// get or set root of AST</span>
  ast.add(pNode);                     <span class="comment">// add ASTNode to tree, linked to current scope</span>
  ASTNode* pNode = ast.find(myType);  <span class="comment">// retrieve ptr to ASTNode representing myType</span>
  ast.pop();                          <span class="comment">// close current scope by poping top of scopeStack</span>

  Build Process:
  ==============
  Required files
  - AbstrSynTree.h, AbstrSynTree.cpp, Utilities.h, Utilities.cpp

  Build commands (either one)
  - devenv CodeAnalysis.sln
  - cl /EHsc /DTEST_ABSTRSYNTREE AbstrSynTree.cpp Utilities.cpp /link setargv.obj

  Maintenance History:
  ====================
  ver 1.5 : 03 Mar 2019
  - fixed size calculation which overflowed on certain namespaces
  ver 1.4 : 26 Feb 2017
  - added parentType_ member to support better grammar analysis
  ver 1.3 : 29 Oct 2016
  - added throw in ScopeStack if pop or peek empty stack
  ver 1.2 : 28 Oct 2016
  - added test for interface in show() and Add(ASTNode*)
  ver 1.1 : 22 Aug 2016
  - added access type and declaration type enumerations
  - added processing to store access level in AST
  - added more prologue comments
  ver 1.0 : 05 Aug 2016
  - first release

*/</span>

#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;sstream&gt;
#include &lt;unordered_map&gt;
#include &lt;functional&gt;
#include "../SemiExpression/ITokenCollection.h"
#include "../ScopeStack/ScopeStack.h"

namespace CodeAnalysis
{
  enum Access 
  { 
    publ, prot, priv 
  };

  enum DeclType 
  { 
    dataDecl, functionDecl, lambdaDecl, usingDecl 
  };

  struct DeclarationNode
  {
    Lexer::ITokenCollection* pTc = nullptr;
    Access access_;
    DeclType declType_;
    std::string package_;
    size_t line_;
  };

  struct ASTNode
  {
    using Type = std::string;
    using Name = std::string;
    using Package = std::string;
    using Path = std::string;

    ASTNode();
    ASTNode(const Type& type, const Name& name);
    ~ASTNode();
    Type type_;
    Type parentType_;
    Name name_;
    Package package_;
    Path path_;
    size_t startLineCount_;
    size_t endLineCount_;
    size_t complexity_;
    std::vector&lt;ASTNode*&gt; children_;
    std::vector&lt;DeclarationNode&gt; decl_;
    std::vector&lt;Lexer::ITokenCollection*&gt; statements_;
    std::string show(bool details = false);
  };

  class AbstrSynTree
  <span class="class">{
  public:
    using ClassName = std::string;
    using TypeMap = std::unordered_map&lt;ClassName, ASTNode*&gt;;

    AbstrSynTree(ScopeStack&lt;ASTNode*&gt;& stack);
    ~AbstrSynTree();
    ASTNode*& root();
    void add(ASTNode* pNode);
    ASTNode* find(const ClassName& type);
    ASTNode* pop();
    TypeMap& typeMap();
  private:
    TypeMap typeMap_;
    ScopeStack&lt;ASTNode*&gt;& stack_;
    ASTNode* pGlobalNamespace_;
  }</span>;
  <span class="comment">//----&lt; traverse AST and execute callobj on every node &gt;-------------</span>

  template &lt;typename CallObj&gt;
  void ASTWalk(ASTNode* pItem, CallObj co)
  <span class="function">{
    static size_t indentLevel = 0;
    co(pItem, indentLevel);
    auto iter = pItem-&gt;children_.begin();
    ++indentLevel;
    while (iter != pItem-&gt;children_.end())
    {
      ASTWalk(*iter, co);
      ++iter;
    }
    --indentLevel;
  }</span>
  <span class="comment">//----&lt; traverse AST and execute callobj on every node &gt;-------------</span>

  template &lt;typename CallObj&gt;
  void ASTWalkNoIndent(ASTNode* pItem, CallObj co)
  <span class="function">{
    co(pItem);
    auto iter = pItem-&gt;children_.begin();
    while (iter != pItem-&gt;children_.end())
    {
      ASTWalkNoIndent(*iter, co);
      ++iter;
    }
  }</span>
  <span class="comment">//----&lt; compute complexities for each ASTNode &gt;--------------------</span>

  inline void complexityWalk(ASTNode* pItem, size_t& count)
  <span class="function">{
    size_t inCount = ++count;
    auto iter = pItem-&gt;children_.begin();
    while (iter != pItem-&gt;children_.end())
    {
      complexityWalk(*iter, count);
      ++iter;
    }
    pItem-&gt;complexity_ = count - inCount + 1;
  }</span>
  <span class="comment">//----&lt; compute complexities for each ASTNode &gt;--------------------</span>

  inline void complexityEval(ASTNode* pNode)
  <span class="function">{
    size_t initialCount = 0;
    complexityWalk(pNode, initialCount);
  }</span>
}

struct foobar {

};
    </pre>
  </body>
</html>
<DOCTYPE !HTML>
<html>
  <head>
    <Title>AbstrSynTree.cpp</Title>
    <script src="script.js"></script>
    <link rel="stylesheet" type="text/css" href="style.css">
  </head>

  <body>
    <span class="absolute">
      <label><input type="checkbox" id ="hideF" value="hidefuncs" checked="true" onclick="toggleVisibility('function')">Functions</label><br>
      <label><input type="checkbox" id ="hideC" value="hideclass" checked="true" onclick="toggleVisibility('class')">Classes</label><br>
      <label><input type="checkbox" id ="hidec" value="hidecomms" checked="true" onclick="toggleVisibility('comment')">Comments</label><br>
    </span>
    <h3>Dependencies: 
      <a href=".html"></a>
      <a href="AbstrSynTree.h.html">AbstrSynTree.h</a>
    </h3>    <pre>
<span class="comment">/////////////////////////////////////////////////////////////////////
//  AbstrSynTree.cpp - Represents an Abstract Syntax Tree          //
//  ver 1.5                                                        //
//  Language:      Visual C++ 2015                                 //
//  Platform:      Dell XPS 8900, Windows 10                       //
//  Application:   Used to support parsing source code             //
//  Author:        Jim Fawcett, CST 4-187, Syracuse University     //
//                 (315) 443-3948, jfawcett@twcny.rr.com           //
/////////////////////////////////////////////////////////////////////</span>

#include "AbstrSynTree.h"
#include "../Utilities/Utilities.h"

using namespace CodeAnalysis;

<span class="comment">//----&lt; default initialization for ASTNodes &gt;------------------------</span>

ASTNode::ASTNode() 
  : type_("anonymous"), parentType_("namespace"), name_("none"), startLineCount_(0), endLineCount_(0), complexity_(0) <span class="function">{}</span>

<span class="comment">//----&lt; initialization accepting type and name &gt;---------------------</span>

ASTNode::ASTNode(const Type& type, const Name& name) 
  : type_(type), parentType_("namespace"), name_(name), startLineCount_(0), endLineCount_(0), complexity_(0) <span class="function">{}</span>

<span class="comment">//----&lt; destructor deletes children, statements, declarations &gt;------</span>

ASTNode::~ASTNode()
<span class="function">{
  for (auto pNode : children_)
    delete pNode;
  for (auto pNode : statements_)
    delete pNode;
  for (auto node : decl_)
  {
    delete node.pTc;
  }
}</span>
<span class="comment">//----&lt; returns string with ASTNode description &gt;--------------------</span>

std::string ASTNode::show(bool details)
<span class="function">{
  std::ostringstream temp;
  temp &lt;&lt; "(";
  temp &lt;&lt; type_ &lt;&lt; ", ";
  temp &lt;&lt; parentType_ &lt;&lt; ", ";
  if(name_ != "none")
    temp &lt;&lt; name_ &lt;&lt; ", ";
  if(type_ == "namespace" || type_ == "class" || type_ == "interface" || type_ == "struct" || type_ == "function")
    temp &lt;&lt; package_ &lt;&lt; ", ";
  if (details)
  {
    temp &lt;&lt; "num children: " &lt;&lt; children_.size() &lt;&lt; ", ";
    temp &lt;&lt; "num statements: " &lt;&lt; statements_.size() &lt;&lt; ", ";
  }
  temp &lt;&lt; "line: " &lt;&lt; startLineCount_ &lt;&lt; ", ";
  int size = static_cast&lt;int&gt;(endLineCount_ - startLineCount_ + 1);
  if (size &lt;= 0)
    size = 1;
  temp &lt;&lt; "size: " &lt;&lt; size &lt;&lt; ", ";
  temp &lt;&lt; "cplx: " &lt;&lt; complexity_;
  <span class="comment">//temp &lt;&lt; "path: " &lt;&lt; path_;</span>
  temp &lt;&lt; ")";
  return temp.str();
}</span>
<span class="comment">//----&lt; create instance and initialize first element &gt;---------------</span>
<span class="comment">/*
*  - Every AST holds an ASTNode representing the global namespace
*  - Its children will be namespaces, classes, and global data
*/</span>
AbstrSynTree::AbstrSynTree(ScopeStack&lt;ASTNode*&gt;& stack) : stack_(stack)
<span class="function">{
  pGlobalNamespace_ = new ASTNode("namespace", "Global Namespace");
  pGlobalNamespace_-&gt;startLineCount_ = 1;
  pGlobalNamespace_-&gt;endLineCount_ = 1;
  stack_.push(pGlobalNamespace_);
}</span>
<span class="comment">//----&lt; destroy instance and all it's ASTNodes &gt;---------------------</span>
<span class="comment">/*
*  AST destructor only has to delete its root.  The root will then
*  delete its children, causing the children to delete their children,
*  yada, yada, yada
*/</span>
AbstrSynTree::~AbstrSynTree()
<span class="function">{
  delete pGlobalNamespace_;
}</span>
<span class="comment">//----&lt; return or accept pointer to global namespace &gt;---------------</span>

ASTNode*& AbstrSynTree::root()
<span class="function">{
  return pGlobalNamespace_;
}</span>
<span class="comment">//----&lt; return AST typemap &gt;-----------------------------------------</span>
<span class="comment">/*
*  Type map holds ClassName keys linked to each class's ASTNode
*/</span>
AbstrSynTree::TypeMap& AbstrSynTree::typeMap()
<span class="function">{
  return typeMap_;
}</span>
<span class="comment">//----&lt; add ASTNode ptr to stack top element's children and push &gt;---</span>
<span class="comment">/*
 * - Add new scope to ScopeStack after linking to its parent scope
 * - If type is a class or struct, add to typeMap
 */</span>
void AbstrSynTree::add(ASTNode* pNode)
<span class="function">{
  if (stack_.size() &gt; 0)
  {
    pNode-&gt;parentType_ = stack_.top()-&gt;type_;
    stack_.top()-&gt;children_.push_back(pNode);  <span class="comment">// add as child of stack top</span>
  }
  else
  {
    pNode-&gt;parentType_ = "";
  }
  stack_.push(pNode);                        <span class="comment">// push onto stack</span>
  if (pNode-&gt;type_ == "class" || pNode-&gt;type_ == "struct" || pNode-&gt;type_ == "interface")
    typeMap_[pNode-&gt;name_] = pNode;
}</span>
<span class="comment">//----&lt; pop stack's top element &gt;------------------------------------</span>
<span class="comment">/*
 *  - called at end of scope
 *  - pop'd ASTNode is still linked to AST
 */</span>
ASTNode* AbstrSynTree::pop()
<span class="function">{
  if(stack_.size() &gt; 0)
    return stack_.pop();
  return nullptr;
}</span>
<span class="comment">//----&lt; find a type node using typeMap &gt;-----------------------------</span>
<span class="comment">/*
*  Retrieve ASTNode of class if it exists
*/</span>
ASTNode* AbstrSynTree::find(const ClassName& className)
<span class="function">{
  auto iter = typeMap_.find(className);
  if (iter != typeMap_.end())
  {
    return iter-&gt;second;
  }
  return nullptr;
}</span>

<span class="comment">//----&lt; Test Stub &gt;--------------------------------------------------</span>
<span class="comment">/*
*  Demonstrates that AbstrSynTree can build a simple Abstract
*  Syntax Tree and display its contents.
*/</span>
#ifdef TEST_ABSTRSYNTREE

#include &lt;functional&gt;
#include &lt;iostream&gt;

using Utils = Utilities::StringHelper;

int main()
<span class="function">{
  Utils::Title("Testing AbstrSynTree and ASTNode");

  ScopeStack&lt;ASTNode*&gt; stack;
  AbstrSynTree ast(stack);
  ASTNode* pX = new ASTNode("class", "X");
  ast.add(pX);                                        <span class="comment">// add X scope</span>
  ASTNode* pf1 = new ASTNode("function", "f1");
  ast.add(pf1);                                       <span class="comment">// add f1 scope</span>
  ASTNode* pc1 = new ASTNode("control", "if");
  ast.add(pc1);                                       <span class="comment">// add c1 scope</span>
  ast.pop();                                          <span class="comment">// end c1 scope</span>
  ast.pop();                                          <span class="comment">// end f1 scope</span>
  ASTNode* pf2 = new ASTNode("function", "f2");
  ast.add(pf2);                                       <span class="comment">// add f2 scope</span>
  ast.pop();                                          <span class="comment">// end f2 scope</span>
  ast.pop();                                          <span class="comment">// end X scope</span>

  std::function&lt;void(ASTNode*, size_t)&gt; co = [](ASTNode* pNode, size_t indentLevel) 
  {
    std::cout &lt;&lt; "\n  " &lt;&lt; std::string(2 * indentLevel, ' ') &lt;&lt; pNode-&gt;show();
  };

  ASTWalk(ast.root(), co);
  std::cout &lt;&lt; "\n";

  Utils::title("testing AbstrSynTree::find");

  ASTNode* pFind = ast.find("X");
  if (pFind != nullptr)
    std::cout &lt;&lt; "\n  " &lt;&lt; pFind-&gt;show();
  else
    std::cout &lt;&lt; "\n  could not find ASTNode for class X";

  std::cout &lt;&lt; "\n\n";
}</span>

#endif
    </pre>
  </body>
</html>
<DOCTYPE !HTML>
<html>
  <head>
    <Title>ActionsAndRules.h</Title>
    <script src="script.js"></script>
    <link rel="stylesheet" type="text/css" href="style.css">
  </head>

  <body>
    <span class="absolute">
      <label><input type="checkbox" id ="hideF" value="hidefuncs" checked="true" onclick="toggleVisibility('function')">Functions</label><br>
      <label><input type="checkbox" id ="hideC" value="hideclass" checked="true" onclick="toggleVisibility('class')">Classes</label><br>
      <label><input type="checkbox" id ="hidec" value="hidecomms" checked="true" onclick="toggleVisibility('comment')">Comments</label><br>
    </span>
    <h3>Dependencies: 
      <a href=".html"></a>
      <a href="ActionsAndRules.cpp.html">ActionsAndRules.cpp</a>
      <a href="AbstrSynTree.h.html">AbstrSynTree.h</a>
    </h3>    <pre>
#ifndef ACTIONSANDRULES_H
#define ACTIONSANDRULES_H
<span class="comment">/////////////////////////////////////////////////////////////////////
//  ActionsAndRules.h - declares new parsing rules and actions     //
//  ver 3.5                                                        //
//  Language:      Visual C++ 2008, SP1                            //
//  Platform:      Dell Precision T7400, Vista Ultimate SP1        //
//  Application:   Prototype for CSE687 Pr1, Sp09                  //
//  Author:        Jim Fawcett, CST 4-187, Syracuse University     //
//                 (315) 443-3948, jfawcett@twcny.rr.com           //
/////////////////////////////////////////////////////////////////////</span>
<span class="comment">/*
  Module Operations: 
  ==================
  This module defines several action classes.  Its classes provide 
  specialized services needed for specific applications.  The modules
  Parser, Semiression, and Tokenizer, are intended to be reusable
  without change.  This module provides a place to put extensions of
  these facilities and is not expected to be reusable. 

  Required files
  ==============
    - Parser.h, Parser.cpp, ScopeStack.h, ScopeStack.cpp,
      ActionsAndRules.h, ActionsAndRules.cpp, ConfigureParser.cpp,
      ITokenCollection.h, Semiression.h, Semiression.cpp, tokenizer.h, tokenizer.cpp

  Maintenance History:
  ====================
  ver 3.5 : 11 Feb 2019
  - small changes spread over many of the Rule and Action classes, caused
    by changing the lexical scanner, which forced some changes to the
    scanner's interface (sigh!)
  ver 3.4 : 28 May 2017
  - Added several tests for scopestack size in actions to fix exceptions
    thrown when processing code that won't compile.
  ver 3.3 : 26 Feb 2017
  - Fixed bug in public data analysis with changes to rule CppDeclaration
    and its action HandleCppDeclaration.
  - Fixed a minor bug in name collection for operators.  Won't be important
    for dependency analysis.
  ver 3.2 : 28 Aug 16
  - fixed errors in many rules and actions based on lots of testing
  - cleaned up text, removing comments and improving prologues
  ver 3.1 : 23 Aug 16
  - qualified input pointers in rules and actions as const
  - cleaned up code by removing unreachables and commented code, and by simplifying 
  ver 3.0 : 06 Aug 16
  - Added use of AbstrSynTree
  - Added new rules and actions
  - Renamed and modified most of the other actions and rules
  ver 2.1 : 15 Feb 16
  - small functional change to a few of the actions changes display strategy
  - preface the (new) Toker and Semi with Lexer namespace
  ver 2.0 : 01 Jun 11
  - added processing on way to building strong code analyzer
  ver 1.1 : 17 Jan 09
  - changed to accept a pointer to interfaced ITokenCollection instead
    of a Semiression
  ver 1.0 : 12 Jan 06
  - first release

  Planned Changes:
  ================
  C++ lambda detection needs strengthening
*/</span>
<span class="comment">//</span>
#include &lt;queue&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include "Parser.h"
#include "../GrammarHelpers/GrammarHelpers.h"
#include "../SemiExpression/ITokenCollection.h"
#include "../ScopeStack/ScopeStack.h"
#include "../Tokenizer/Toker.h"
#include "../SemiExpression/Semi.h"
#include "../AbstractSyntaxTree/AbstrSynTree.h"
#include "../Logger/Logger.h"
#include "../FileSystem/FileSystem.h"

namespace CodeAnalysis
{  
  <span class="comment">///////////////////////////////////////////////////////////////////
  // Repository instance is used to share resources
  // among all actions.</span>

  enum Language { C <span class="comment">/* not implemented */</span>, Cpp, CSharp };

  class Repository  <span class="comment">// application specific</span>
  <span class="class">{
  public:
    using Rslt = Logging::StaticLogger&lt;0&gt;;  <span class="comment">// use for application results</span>
    using Demo = Logging::StaticLogger&lt;1&gt;;  <span class="comment">// use for demonstrations of processing</span>
    using Dbug = Logging::StaticLogger&lt;2&gt;;  <span class="comment">// use for debug output</span>
    using Package = std::string;
    using Path = std::string;

  private:
    Language language_ = Language::Cpp;
    Path path_;
    ScopeStack&lt;ASTNode*&gt; stack;
    AbstrSynTree ast;
    ASTNode* pGlobalScope;
    Package package_;
    Lexer::Toker* p_Toker;
    Access currentAccess_ = Access::publ;
    static Repository* instance;
  
  public:
    
    Repository(Lexer::Toker* pToker) : ast(stack)
    <span class="function">{
      p_Toker = pToker;
      pGlobalScope = stack.top();  <span class="comment">// installed in AST constructor</span>
      instance = this;
    }</span>

    ~Repository()
    <span class="function">{
      Dbug::write("\n  deleting repository");
    }</span>

    Language& language() <span class="function">{ return language_; }</span>

    Package& package() <span class="function">{ return package_; }</span>

    Path& currentPath() <span class="function">{ return path_; }</span>

    Access& currentAccess() <span class="function">{ return currentAccess_; }</span>

    static Repository* getInstance() <span class="function">{ return instance; }</span>

    ScopeStack&lt;ASTNode*&gt;& scopeStack() <span class="function">{ return stack; }</span>

    AbstrSynTree& AST() <span class="function">{ return ast; }</span>

    ASTNode* getGlobalScope() <span class="function">{ return pGlobalScope; }</span>

    Lexer::Toker* Toker() <span class="function">{ return p_Toker; }</span>

    size_t lineCount() 
    <span class="function">{ 
      return (size_t)(p_Toker-&gt;lineCount()); 
    }</span>
  }</span>;

  <span class="comment">///////////////////////////////////////////////////////////////
  // rule to detect beginning of scope</span>

  class BeginScope : public IRule
  <span class="class">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Test begin scope", *pTc);

      <span class="comment">// don't parse Semi with single semicolon token</span>

      if (pTc-&gt;size() == 1 && (*pTc)[0] == ";")
        return IRule::Stop;

      if (pTc-&gt;contains("{"))
      {
        doActions(pTc);
      }
      return IRule::Continue;
    }</span>
  }</span>;

  <span class="comment">///////////////////////////////////////////////////////////////
  // action to handle scope stack at beginning of scope</span>

  class HandleBeginScope : public IAction
  <span class="class">{
    Repository* p_Repos;
  public:
    HandleBeginScope(Repository* pRepos)
    <span class="function">{
      p_Repos = pRepos;
    }</span>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("handle begin scope", *pTc);

      ASTNode* pElem = new ASTNode;
      pElem-&gt;type_ = "anonymous";
      pElem-&gt;name_ = "none";
      pElem-&gt;package_ = p_Repos-&gt;package();
      pElem-&gt;startLineCount_ = p_Repos-&gt;lineCount();
      pElem-&gt;endLineCount_ = 1;
      pElem-&gt;path_ = p_Repos-&gt;currentPath();
      <span class="comment">/*
       * make this ASTNode child of ASTNode on stack top
       * then push onto stack
       */</span>
      p_Repos-&gt;AST().add(pElem);
    }</span>
  }</span>;

  <span class="comment">///////////////////////////////////////////////////////////////
  // rule to detect end of scope</span>

  class EndScope : public IRule
  <span class="class">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Test end scope", *pTc);

      size_t posCloseBrace;
      pTc-&gt;find("}", posCloseBrace);
      if (posCloseBrace &lt; pTc-&gt;size())
      {
        doActions(pTc);
        return IRule::Stop;
      }
      return IRule::Continue;
    }</span>
  }</span>;

  <span class="comment">///////////////////////////////////////////////////////////////
  // action to handle scope stack at end of scope</span>

  class HandleEndScope : public IAction
  <span class="class">{
    Repository* p_Repos;
  public:
    using Dbug = Logging::StaticLogger&lt;2&gt;;

    HandleEndScope(Repository* pRepos)
    <span class="function">{
      p_Repos = pRepos;
    }</span>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Handle end scope", *pTc);

      if (p_Repos-&gt;scopeStack().size() == 0)
        return;

      ASTNode* pElem = p_Repos-&gt;AST().pop();
      if (pElem == nullptr)
        return;

      pElem-&gt;endLineCount_ = p_Repos-&gt;lineCount();
      if (pElem-&gt;type_ == "class" || pElem-&gt;type_ == "struct")
        (pElem-&gt;endLineCount_)++;

      p_Repos-&gt;currentAccess() = Access::priv;
    }</span>
  }</span>;

  <span class="comment">///////////////////////////////////////////////////////////////
  // rule to detect access for C++</span>

  class DetectAccessSpecifier : public IRule
  <span class="class">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Test access spec", *pTc);

      Repository* pRepo = Repository::getInstance();
      if (pRepo-&gt;language() != Language::Cpp)
        return IRule::Continue;

      size_t pos;
      pTc-&gt;find(":", pos);
      if (0 &lt; pos && pos &lt; pTc-&gt;size())
      {
        const std::string tok = (*pTc)[pos - 1];
        if (tok == "public" || tok == "protected" || tok == "private")
        {
          doActions(pTc);
          return IRule::Stop;
        }
      }
      return IRule::Continue;
    }</span>
  }</span>;

  <span class="comment">///////////////////////////////////////////////////////////////
  // action to handle access specifier</span>

  class HandleAccessSpecifier : public IAction
  <span class="class">{
    Repository* p_Repos;

  public:
    HandleAccessSpecifier(Repository* pRepos)
    <span class="function">{
      p_Repos = pRepos;
    }</span>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Handle access spec: ", *pTc);

      std::string tok = (*pTc)[pTc-&gt;size() - 2];
      Access& access = p_Repos-&gt;currentAccess();
      if (tok == "public")
        access = Access::publ;
      else if (tok == "protected")
        access = Access::prot;
      else
        access = Access::priv;
    }</span>
  }</span>;

  <span class="comment">///////////////////////////////////////////////////////////////
  // rule to detect preprocessor statements</span>

  class PreprocStatement : public IRule
  <span class="class">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Test preproc statement: ", *pTc);

      size_t pPos;
      pTc-&gt;find("#", pPos);
      if (pPos &lt; pTc-&gt;size())
      {
        doActions(pTc);
        return IRule::Stop;
      }
      return IRule::Continue;
    }</span>
  }</span>;

  <span class="comment">///////////////////////////////////////////////////////////////
  // action to add Semi to scope stack top statements_</span>

  class HandlePreprocStatement : public IAction
  <span class="class">{
    Repository* p_Repos;

  public:
    HandlePreprocStatement(Repository* pRepos)
    <span class="function">{
      p_Repos = pRepos;
    }</span>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Handle preproc statement: ", *pTc);

      Lexer::ITokenCollection* pClone = pTc-&gt;clone();
      if (p_Repos-&gt;scopeStack().size() == 0)
        return;
      ASTNode* pElem = p_Repos-&gt;scopeStack().top();
      pElem-&gt;statements_.push_back(pClone);

      GrammarHelper::showParse("Preproc Stmt", *pTc);
    }</span>
  }</span>;

  <span class="comment">///////////////////////////////////////////////////////////////
  // rule to detect namespace statements</span>

  class NamespaceDefinition : public IRule
  <span class="class">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Test namespace definition: ", *pTc);

      const Lexer::ITokenCollection& tc = *pTc;
      if (tc[tc.size() - 1] == "{")
      {
        size_t len;
        tc.find("namespace", len);
        if (len &lt; tc.size())
        {
          doActions(pTc);
          return IRule::Stop;
        }
      }
      return IRule::Continue;
    }</span>
  }</span>;

  <span class="comment">///////////////////////////////////////////////////////////////
  // action to add namespace info to scope stack top</span>

  class HandleNamespaceDefinition : public IAction
  <span class="class">{
    Repository* p_Repos;

  public:
    HandleNamespaceDefinition(Repository* pRepos)
    <span class="function">{
      p_Repos = pRepos;
    }</span>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Handle namespace definition: ", *pTc);

      if (p_Repos-&gt;scopeStack().size() == 0)
        return;

      ASTNode* top = p_Repos-&gt;scopeStack().top();

      size_t pos;
      pTc-&gt;find("namespace", pos);
      std::string name = (*pTc)[pos + 1];
      top-&gt;type_ = "namespace";
      top-&gt;name_ = name;
      top-&gt;package_ = p_Repos-&gt;package();

      GrammarHelper::showParse("namespace def", *pTc);
    }</span>
  }</span>;

  <span class="comment">///////////////////////////////////////////////////////////////
  // rule to detect class statements</span>

  class ClassDefinition : public IRule
  <span class="class">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Test class definition: ", *pTc);

      const Lexer::ITokenCollection& tc = *pTc;
      if (tc[tc.size() - 1] == "{")
      {
        size_t len;
        tc.find("class", len);
        if (len &lt; tc.size())
        {
          doActions(pTc);
          return IRule::Stop;
        }
        if (tc.contains("interface"))
        {
          doActions(pTc);
          return IRule::Stop;
        }
      }
      return IRule::Continue;
    }</span>
  }</span>;

  <span class="comment">///////////////////////////////////////////////////////////////
  // action to add class info to scope stack top</span>

  class HandleClassDefinition : public IAction
  <span class="class">{
    Repository* p_Repos;

  public:
    HandleClassDefinition(Repository* pRepos)
    <span class="function">{
      p_Repos = pRepos;
    }</span>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Handle class definition: ", *pTc);

      p_Repos-&gt;currentAccess() = Access::priv;

      if (p_Repos-&gt;scopeStack().size() == 0)
        return;

      ASTNode* top = p_Repos-&gt;scopeStack().top();
      size_t typeIndex;
      pTc-&gt;find("class", typeIndex);
      if (typeIndex &lt; pTc-&gt;size())
      {
        size_t nameIndex = typeIndex + 1;
        std::string name = (*pTc)[nameIndex];
        top-&gt;type_ = "class";
        top-&gt;name_ = name;
        top-&gt;package_ = p_Repos-&gt;package();
        p_Repos-&gt;AST().typeMap()[name] = top;
        GrammarHelper::showParse("class def", *pTc);
      }
      else  <span class="comment">// C#</span>
      {
        pTc-&gt;find("interface", typeIndex);
        size_t nameIndex = typeIndex + 1;
        std::string name = (*pTc)[nameIndex];
        top-&gt;type_ = "interface";
        top-&gt;name_ = name;
        top-&gt;package_ = p_Repos-&gt;package();
        p_Repos-&gt;AST().typeMap()[name] = top;
        GrammarHelper::showParse("interface def", *pTc);
      }
    }</span>
  }</span>;

  <span class="comment">///////////////////////////////////////////////////////////////
  // rule to detect struct statements</span>

  class StructDefinition : public IRule
  <span class="class">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Test struct definition: ", *pTc);

      const Lexer::ITokenCollection& tc = *pTc;
      if (tc[tc.size() - 1] == "{")
      {
        size_t len;
        tc.find("struct", len);
        if (len &lt; tc.size())
        {
          doActions(pTc);
          return IRule::Stop;
        }
      }
      return IRule::Continue;
    }</span>
  }</span>;

  <span class="comment">///////////////////////////////////////////////////////////////
  // action to add struct info to scope stack top</span>

  class HandleStructDefinition : public IAction
  <span class="class">{
    Repository* p_Repos;

  public:
    HandleStructDefinition(Repository* pRepos)
    <span class="function">{
      p_Repos = pRepos;
    }</span>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Handle struct definition: ", *pTc);

      p_Repos-&gt;currentAccess() = Access::publ;

      if (p_Repos-&gt;scopeStack().size() == 0)
        return;

      ASTNode* top = p_Repos-&gt;scopeStack().top();

      size_t pos;
      pTc-&gt;find("struct", pos);
      std::string name = (*pTc)[pos + 1];
      top-&gt;type_ = "struct";
      top-&gt;name_ = name;
      top-&gt;package_ = p_Repos-&gt;package();
      p_Repos-&gt;AST().typeMap()[name] = top;

      GrammarHelper::showParse("struct def", *pTc);
    }</span>
  }</span>;

  <span class="comment">///////////////////////////////////////////////////////////////
  // rule to detect C++ function definitions</span>

  class CppFunctionDefinition : public IRule
  <span class="class">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      Repository* pRepo = Repository::getInstance();
      if (pRepo-&gt;language() != Language::Cpp)
        return IRule::Continue;

      GrammarHelper::showParseDemo("Test C++ function definition: ", *pTc);

      ScopeStack&lt;ASTNode*&gt;& stack = pRepo-&gt;scopeStack();
      if (stack.size() &lt; 2)
        return IRule::Continue;

      std::string parentType = stack.predOfTop()-&gt;type_;
      if (parentType != "namespace" && parentType != "class" && parentType != "struct")
        return IRule::Continue;

      const Lexer::ITokenCollection& tc = *pTc;

      if (tc[tc.size() - 1] == "{")
      {
        if (GrammarHelper::isFunction(*pTc))
        {
          doActions(pTc);
          return IRule::Stop;
        }
      }
      return IRule::Continue;
    }</span>
  }</span>;

  <span class="comment">///////////////////////////////////////////////////////////////
  // action to add function info to scope stack top</span>

  class HandleCppFunctionDefinition : public IAction
  <span class="class">{
    Repository* p_Repos;

  public:
    HandleCppFunctionDefinition(Repository* pRepos)
    <span class="function">{
      p_Repos = pRepos;
    }</span>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Handle C++ function definition: ", *pTc);

      ScopeStack&lt;ASTNode*&gt;& stack = p_Repos-&gt;scopeStack();
     
      if (stack.size() == 0)
        return;

      ASTNode* top = stack.top();

      size_t nameIndex;
      if(pTc-&gt;find("(", nameIndex))
      --nameIndex;
      else return;
      std::string name = (*pTc)[nameIndex];

      <span class="comment">// is function a destructor?</span>

      if (nameIndex &gt; 0 && (*pTc)[nameIndex - 1] == "~")
      {
        --nameIndex;
        name = "~" + name;
      }

      top-&gt;type_ = "function";
      top-&gt;name_ = name;
      top-&gt;package_ = p_Repos-&gt;package();
      GrammarHelper::showParse("function def", *pTc);

      <span class="comment">// is function an operator?</span>

      size_t operIndex;
      pTc-&gt;find("operator", operIndex);
      if (operIndex &lt; pTc-&gt;size())
      {
        name = "operator" + (*pTc)[operIndex + 1];<span class="comment">// +(*pTc)[operIndex + 2];</span>
        if ((*pTc)[operIndex + 2] != "(")
          name += (*pTc)[operIndex + 2];
        top-&gt;name_ = name;
        nameIndex = operIndex;
      }
      <span class="comment">// is function a member of a class or struct?</span>

      if (nameIndex &gt; 1 && (*pTc)[nameIndex - 1] == "::")
      {
        <span class="comment">//----&lt; start find class name &gt;--------------------</span>

        std::string className = (*pTc)[nameIndex - 2];

        <span class="comment">// is class a template?</span>

        if (className == "&gt;")
        {
          size_t startParam = GrammarHelper::findLast(*pTc, "&lt;");
          if (0 &lt; startParam && startParam &lt; pTc-&gt;size())
            className = (*pTc)[startParam - 1];
        }
        <span class="comment">//----&lt; end find class name &gt;----------------------</span>
        <span class="comment">/*
        * - this function's ASTNode is at stack top
        * - find ASTNode of function's class
        * - unlink function ASTNode from stack top predecessor
        * - relink function ASTNode to it's class ASTNode
        * - leave function ASTNode on stack top as it may have child nodes
        */</span>
        ASTNode* pClassNode = p_Repos-&gt;AST().find(className);
        if (pClassNode == nullptr)
          return;
        if (p_Repos-&gt;scopeStack().size() &lt; 2)
          return;

        ASTNode* pFunctNode = p_Repos-&gt;scopeStack().top();
        ASTNode* pParentNode = p_Repos-&gt;scopeStack().predOfTop();
        if(pParentNode-&gt;children_.size() &gt; 0)
          pParentNode-&gt;children_.pop_back();           <span class="comment">// unlink function</span>
        pFunctNode-&gt;parentType_ = pClassNode-&gt;type_;
        pClassNode-&gt;children_.push_back(pFunctNode);   <span class="comment">// relink function</span>
        return;
      }
      <span class="comment">// is this a lambda?</span>

      std::string packageName = p_Repos-&gt;package();
      std::string ext = FileSystem::Path::getExt(packageName);

      size_t posOpenBracket;
      pTc-&gt;find("[", posOpenBracket);
      size_t posCloseBracket;
      pTc-&gt;find("]", posCloseBracket);
      size_t posBrace;
      pTc-&gt;find("{", posBrace);
      size_t posOpenParen;
      pTc-&gt;find("(", posOpenParen);
      if (posCloseBracket != posBrace + 1 && posCloseBracket != posOpenParen + 1) <span class="comment">// []{ or [](</span>
        return;
      if (posOpenBracket &lt; posCloseBracket && posBrace == (posCloseBracket + 1) && posBrace &lt; pTc-&gt;size())
      {
        std::string name;
        for (size_t i = posOpenBracket; i &lt; posBrace; ++i)
          name += (*pTc)[i];
        top-&gt;name_ = name;
        top-&gt;type_ = "lambda";
      }
    }</span>
  }</span>;

  <span class="comment">///////////////////////////////////////////////////////////////
  // rule to detect C# function definitions</span>

  class CSharpFunctionDefinition : public IRule
  <span class="class">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      Repository* pRepo = Repository::getInstance();
      if (pRepo-&gt;language() != Language::CSharp)
        return IRule::Continue;

      GrammarHelper::showParseDemo("Test C# function definition: ", *pTc);

      const Lexer::ITokenCollection& tc = *pTc;
      if (tc[tc.size() - 1] == "{")
      {
        Lexer::Semi se;
        for (size_t i = 0; i &lt; tc.size(); ++i)
          se.add(tc[i]);

        if (GrammarHelper::isFunction(se))
        {
          doActions(&se);
          return IRule::Stop;
        }
      }
      return IRule::Continue;
    }</span>
  }</span>;

  <span class="comment">///////////////////////////////////////////////////////////////
  // action to add function info to scope stack top</span>

  class HandleCSharpFunctionDefinition : public IAction
  <span class="class">{
    Repository* p_Repos;

  public:
    HandleCSharpFunctionDefinition(Repository* pRepos)
    <span class="function">{
      p_Repos = pRepos;
    }</span>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Handle C# function definition: ", *pTc);

      if (p_Repos-&gt;scopeStack().size() == 0)
        return;

      ASTNode* top = p_Repos-&gt;scopeStack().top();

      size_t nameIndex;
      if (pTc-&gt;find("(", nameIndex))
        --nameIndex;
      else
        return;

      std::string name = (*pTc)[nameIndex];

      <span class="comment">// is function a destructor?</span>

      if (nameIndex &gt; 0 && (*pTc)[nameIndex - 1] == "~")
      {
        --nameIndex;
        name = "~" + name;
      }

      top-&gt;type_ = "function";
      top-&gt;name_ = name;
      top-&gt;package_ = p_Repos-&gt;package();

      GrammarHelper::showParse("function def", *pTc);

      <span class="comment">// is function an operator?</span>

      size_t operIndex;
      pTc-&gt;find("operator", operIndex);
      if (operIndex &lt; pTc-&gt;size())
      {
        name = "operator" + (*pTc)[operIndex + 1] + (*pTc)[operIndex + 2];
        top-&gt;name_ = name;
        nameIndex = operIndex;
      }

      <span class="comment">// is lambda?</span>

      size_t posParen;
      pTc-&gt;find("(", posParen);
      size_t posBrace;
      pTc-&gt;find("{", posBrace);
      size_t posEqual;
      pTc-&gt;find("=", posEqual);
      if (posParen &lt; posBrace && posBrace &lt; pTc-&gt;size())
      {
        if (posEqual &lt; pTc-&gt;size() - 1 && (*pTc)[posEqual + 1] == "&gt;")
        {
          std::string name;
          for (size_t i = posParen; i &lt;= posBrace; ++i)
            name += (*pTc)[i];
          top-&gt;name_ = name;
          top-&gt;type_ = "lambda";
        }
      }
    }</span>
  }</span>;

  <span class="comment">///////////////////////////////////////////////////////////////
  // rule to detect control definitions</span>

  class ControlDefinition : public IRule
  <span class="class">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Test control definition: ", *pTc);

      const Lexer::ITokenCollection& tc = *pTc;
      if (tc[tc.size() - 1] == "{")
      {
        size_t len;
        tc.find("(", len);
        if (len &lt; tc.size() && GrammarHelper::isControlKeyWord(tc[len - 1]))
        {
          doActions(pTc);
          return IRule::Stop;
        }
        else if (tc.size() &gt; 1 && GrammarHelper::isControlKeyWord(tc[tc.size() - 2]))
        {
          doActions(pTc);
          return IRule::Stop;
        }
      }
      return IRule::Continue;
    }</span>
  }</span>;

  <span class="comment">///////////////////////////////////////////////////////////////
  // action to add control info to scope stack top</span>

  class HandleControlDefinition : public IAction
  <span class="class">{
    Repository* p_Repos;

  public:
    HandleControlDefinition(Repository* pRepos)
    <span class="function">{
      p_Repos = pRepos;
    }</span>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Handle control definition: ", *pTc);

      if (p_Repos-&gt;scopeStack().size() == 0)
        return;

      ASTNode* top;
      if ((p_Repos-&gt;scopeStack()).size() &gt; 0)
        top = p_Repos-&gt;scopeStack().top();
      else
        return;

      size_t nameIndex;
      if(pTc-&gt;find("(", nameIndex))         <span class="comment">// if, for, while, switch, catch</span>
        --nameIndex;
      <span class="comment">//if (nameIndex == pTc-&gt;size() - 1)     // do, try - they don't have parens</span>
      else
        nameIndex = pTc-&gt;size() - 2;
      std::string name = (*pTc)[nameIndex];
      top-&gt;type_ = "control";
      top-&gt;name_ = name;

      GrammarHelper::showParse("control def", *pTc);
    }</span>
  }</span>;

  <span class="comment">///////////////////////////////////////////////////////////////
  // action to send semi-expression that starts a function def
  // to console</span>

  class PrintFunction : public IAction
  <span class="class">{
    Repository* p_Repos;
  public:
    using Rslt = Logging::StaticLogger&lt;0&gt;;

    PrintFunction(Repository* pRepos)
    <span class="function">{
      p_Repos = pRepos;
    }</span>
    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      std::ostringstream out;
      <span class="comment">//out &lt;&lt; "\n  FuncDef: " &lt;&lt; pTc-&gt;show().c_str();</span>
      Rslt::write(out.str());
    }</span>
  }</span>;

  <span class="comment">///////////////////////////////////////////////////////////////
  // action to send signature of a function def to console</span>

  class PrettyPrintFunction : public IAction
  <span class="class">{
    Repository* p_Repos;
  public:
    using Rslt = Logging::StaticLogger&lt;0&gt;;

    PrettyPrintFunction(Repository* pRepos) : p_Repos(pRepos) <span class="function">{}</span>

    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      size_t len;
      pTc-&gt;find(")", len);

      std::ostringstream out;
      out &lt;&lt; "\n\n  Pretty Stmt:    ";
      for (size_t i = 0; i &lt; len + 1; ++i)
        out &lt;&lt; (*pTc)[i] &lt;&lt; " ";
      out &lt;&lt; "\n";
      Rslt::write(out.str());
    }</span>
  }</span>;

  <span class="comment">///////////////////////////////////////////////////////////////
  // rule to detect C++ Declaration</span>
  <span class="comment">/*
  *  - Declaration ends in semicolon
  *  - has type, name, modifiers & initializers
  *  So:
  *  - strip off modifiers and initializers
  *  - if you have two things left it's a declar, else executable
  */</span>
  class CppDeclaration : public IRule
  <span class="class">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      Repository* pRepo = Repository::getInstance();
      if (pRepo-&gt;language() != Language::Cpp)
        return IRule::Continue;

      GrammarHelper::showParseDemo("Test C++ declaration: ", *pTc);

      Lexer::Semi tc;
      tc.clone(*pTc);

      <span class="comment">// begin added 2/26/2017</span>

      Access access = pRepo-&gt;currentAccess();
      bool isPublic = false;

      if (pRepo-&gt;scopeStack().size() == 0)
        return false;

      std::string parentType = pRepo-&gt;scopeStack().top()-&gt;type_;

      size_t posPrivate;
      pTc-&gt;find("private", posPrivate);
      if (posPrivate &lt; pTc-&gt;size())
      {
        isPublic = false;
        pRepo-&gt;currentAccess() = Access::priv;
      }

      size_t posProtected;
      pTc-&gt;find("protected", posProtected);
      if (posProtected &lt; pTc-&gt;size())
      {
        isPublic = false;
        pRepo-&gt;currentAccess() = Access::prot;
      }

      size_t posPublic;
      pTc-&gt;find("public", posPublic);
      if (posPublic &lt; pTc-&gt;size() && parentType != "function")
      {
        isPublic = true;
        pRepo-&gt;currentAccess() = Access::publ;
      }

      <span class="comment">// end added 2/26/2017</span>

      if (tc.size() &gt; 0 && tc[0] == "using")
      {
        doActions(pTc);
        return IRule::Stop;
      }

      if (tc[tc.size() - 1] == ";" && tc.size() &gt; 2)
      {
        std::string nextToLast = tc[tc.size() - 2];
        if (nextToLast == "delete" || nextToLast == "default" || nextToLast == "const")
        {
          {
            <span class="comment">// function declaration</span>
            doActions(pTc);
            return IRule::Stop;
          }
        }
        std::string parentType = pRepo-&gt;scopeStack().top()-&gt;type_;
        
        if (GrammarHelper::isDataDeclaration(tc) || GrammarHelper::isFunctionDeclaration(tc, parentType))
        {
          doActions(pTc);
          return IRule::Stop;
        }

        if (parentType != "function")
        {
          <span class="comment">// can't be executable so must be declaration</span>

          doActions(pTc);
          return IRule::Stop;
        }
      }
      return IRule::Continue;
    }</span>
  }</span>;

  <span class="comment">///////////////////////////////////////////////////////////////
  // action to add declaration info to scope stack top</span>

  class HandleCppDeclaration : public IAction
  <span class="class">{
    Repository* p_Repos;

  public:
    HandleCppDeclaration(Repository* pRepos) : p_Repos(pRepos) <span class="function">{}</span>

    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Handle C++ declaration: ", *pTc);

      <span class="comment">// save declaration info in ASTNode</span>

      if (p_Repos-&gt;scopeStack().size() == 0)
        return;

      ASTNode* pCurrNode = p_Repos-&gt;scopeStack().top();
      DeclarationNode declNode;
      declNode.access_ = p_Repos-&gt;currentAccess();
      declNode.pTc = pTc-&gt;clone();
      declNode.package_ = p_Repos-&gt;package();
      declNode.line_ = p_Repos-&gt;lineCount();

      Lexer::Semi se;
      se.clone(*pTc);
      GrammarHelper::removeComments(se);

      if (se[0] == "using")
      {
        declNode.declType_ = DeclType::usingDecl;
        pCurrNode-&gt;decl_.push_back(declNode);

        GrammarHelper::showParse("using declar", *pTc);
        return;
      }

      if (GrammarHelper::isFunctionDeclaration(se,"parentNotFunction"))
      {
        return;
      }

      if (GrammarHelper::isDataDeclaration(se))
      {
        declNode.declType_ = DeclType::dataDecl;
        pCurrNode-&gt;decl_.push_back(declNode);
        GrammarHelper::showParse("data declar", *pTc);
      }
    }</span>
  }</span>;

  <span class="comment">///////////////////////////////////////////////////////////////
  // rule to detect C# Declaration</span>
  <span class="comment">/*
  *  - Declaration ends in semicolon
  *  - has type, name, modifiers & initializers
  *  So:
  *  - strip of modifiers and initializers
  *  - if you have two things left it's a declar, else executable
  */</span>
  class CSharpDeclaration : public IRule
  <span class="class">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      Repository* pRepo = Repository::getInstance();
      if (pRepo-&gt;language() != Language::CSharp)
        return IRule::Continue;

      GrammarHelper::showParseDemo("Test C# declaration: ", *pTc);

      Access access = pRepo-&gt;currentAccess();
      bool isPublic = false;

      if (pRepo-&gt;scopeStack().size() == 0)
        return false;

      std::string parentType = pRepo-&gt;scopeStack().top()-&gt;type_;

      size_t posPublic;
      pTc-&gt;find("public", posPublic);
      if (posPublic &lt; pTc-&gt;size() && parentType != "function")
      {
        isPublic = true;
        pRepo-&gt;currentAccess() = Access::publ;
      }

      const Lexer::ITokenCollection& tc = *pTc;
      if (tc.size() &gt; 0 && tc[0] == "using")
      {
        doActions(pTc);
        pRepo-&gt;currentAccess() = access;
        return IRule::Stop;
      }

      Lexer::Semi se;
      se.clone(*pTc);

      if (GrammarHelper::isDataDeclaration(se))
      {
        doActions(pTc);
        pRepo-&gt;currentAccess() = access;
        return IRule::Stop;
      }

      if (GrammarHelper::isFunctionDeclaration(se, parentType))
      {
        doActions(pTc);
        pRepo-&gt;currentAccess() = access;
        return IRule::Stop;
      }
      return IRule::Continue;
    }</span>
  }</span>;

  <span class="comment">///////////////////////////////////////////////////////////////
  // action to add declaration info to scope stack top</span>

  class HandleCSharpDeclaration : public IAction
  <span class="class">{
    Repository* p_Repos;

  public:
    HandleCSharpDeclaration(Repository* pRepos) : p_Repos(pRepos) <span class="function">{}</span>

    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Handle C# declaration: ", *pTc);

      <span class="comment">// store declaration info in ASTNode</span>

      if (p_Repos-&gt;scopeStack().size() == 0)
        return;

      ASTNode* pCurrNode = p_Repos-&gt;scopeStack().top();
      DeclarationNode declNode;
      declNode.access_ = p_Repos-&gt;currentAccess();
      declNode.pTc = pTc-&gt;clone();
      declNode.package_ = p_Repos-&gt;package();
      declNode.line_ = p_Repos-&gt;lineCount();

      Lexer::Semi se;
      se.clone(*pTc);
      GrammarHelper::removeComments(se);

      if (se[0] == "using")
      {
        declNode.declType_ = DeclType::usingDecl;
        pCurrNode-&gt;decl_.push_back(declNode);

        GrammarHelper::showParse("using declar", *pTc);
        return;
      }

      std::string parentType = p_Repos-&gt;scopeStack().top()-&gt;type_;

      if (GrammarHelper::isFunctionDeclaration(se, parentType))
      {
        Access adebug = declNode.access_;
        declNode.declType_ = DeclType::functionDecl;
        pCurrNode-&gt;decl_.push_back(declNode);
        GrammarHelper::showParse("function declar", *pTc);
      }
      else
      {
        Access adebug = declNode.access_;
        declNode.declType_ = DeclType::dataDecl;
        pCurrNode-&gt;decl_.push_back(declNode);
        GrammarHelper::showParse("data declar", *pTc);
      }
    }</span>
  }</span>;

  <span class="comment">///////////////////////////////////////////////////////////////
  // rule to detect C++ Executable</span>

  class CppExecutable : public IRule
  <span class="class">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      Repository* pRepo = Repository::getInstance();
      if (pRepo-&gt;language() != Language::Cpp)
        return IRule::Continue;

      GrammarHelper::showParseDemo("Test C++ executable: ", *pTc);

      Lexer::Semi tc;
      tc.clone(*pTc);

      if (tc[tc.size() - 1] == ";" && tc.size() &gt; 2)
      {
        GrammarHelper::removeFunctionArgs(tc);
        GrammarHelper::condenseTemplateTypes(tc);

        <span class="comment">// remove modifiers, comments, newlines, returns, and initializers</span>

        Lexer::Semi se;
        for (size_t i = 0; i &lt; tc.size(); ++i)
        {
          if (GrammarHelper::isQualifierKeyWord(tc[i]))
            continue;
          if (se.isComment(tc[i]) || tc[i] == "\n" || tc[i] == "return")
            continue;
          if (tc[i] == "=" || tc[i] == ";")
          {
            se.add(";");
            break;
          }
          else
            se.add(tc[i]);
        }
        if (se.size() != 3)  <span class="comment">// not a declaration</span>
        {
          doActions(pTc);
          return IRule::Stop;
        }
      }
      return IRule::Continue;
    }</span>
  }</span>;

  <span class="comment">///////////////////////////////////////////////////////////////
  // action to display C++ executable info</span>

  class HandleCppExecutable : public IAction
  <span class="class">{
    Repository* p_Repo;

  public:
    HandleCppExecutable(Repository* pRepo) : p_Repo(pRepo) <span class="function">{}</span>

    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Handle C++ executable: ", *pTc);

      GrammarHelper::showParse("executable", *pTc);
    }</span>
  }</span>;
  <span class="comment">///////////////////////////////////////////////////////////////
  // rule to detect C# Executable</span>

  class CSharpExecutable : public IRule
  <span class="class">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      Repository* pRepo = Repository::getInstance();
      if (pRepo-&gt;language() != Language::CSharp)
        return IRule::Continue;

      GrammarHelper::showParseDemo("Test C# executable: ", *pTc);

      const Lexer::ITokenCollection& in = *pTc;
      Lexer::Semi tc;
      for (size_t i = 0; i &lt; in.size(); ++i)
        tc.add(in[i]);

      if (tc[tc.size() - 1] == ";" && tc.size() &gt; 2)
      {
        GrammarHelper::removeFunctionArgs(tc);
        GrammarHelper::condenseTemplateTypes(tc);

        <span class="comment">// remove modifiers, comments, newlines, returns, and initializers</span>

        Lexer::Semi se;
        for (size_t i = 0; i &lt; tc.size(); ++i)
        {
          if (GrammarHelper::isQualifierKeyWord(tc[i]))
            continue;
          if (se.isComment(tc[i]) || tc[i] == "\n" || tc[i] == "return")
            continue;
          if (tc[i] == "=" || tc[i] == ";")
          {
            se.add(";");
            break;
          }
          else
            se.add(tc[i]);
        }
        if (se.size() != 3)  <span class="comment">// not a declaration</span>
        {
          doActions(pTc);
          return IRule::Stop;
        }
      }
      return IRule::Continue;
    }</span>
  }</span>;
  <span class="comment">///////////////////////////////////////////////////////////////
  // action to display C# executable info</span>

  class HandleCSharpExecutable : public IAction
  <span class="class">{
    Repository* p_Repo;

  public:
    HandleCSharpExecutable(Repository* pRepo) : p_Repo(pRepo) <span class="function">{}</span>

    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Handle C# executable: ", *pTc);

      Lexer::Semi se;
      se.clone(*pTc);
      GrammarHelper::removeComments(se);

      GrammarHelper::showParse("executable", se);
    }</span>
  }</span>;
  <span class="comment">///////////////////////////////////////////////////////////////
  // default rule
  // - this is here to catch any Semi that didn't parse
  // - We don't have rule for enums, so they are caugth here</span>

  class Default : public IRule
  <span class="class">{
  public:
    bool doTest(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Test default: ", *pTc);

      doActions(pTc);  <span class="comment">// catches everything</span>
      return IRule::Stop;
    }</span>
  }</span>;
  <span class="comment">///////////////////////////////////////////////////////////////
  // action to display default info</span>

  class HandleDefault : public IAction
  <span class="class">{
    Repository* p_Repo;

  public:
    HandleDefault(Repository* pRepo) : p_Repo(pRepo) <span class="function">{}</span>

    void doAction(const Lexer::ITokenCollection* pTc) override
    <span class="function">{
      GrammarHelper::showParseDemo("Handle default: ", *pTc);
      GrammarHelper::showParse("default: ", *pTc);
    }</span>
  }</span>;
}
#endif
    </pre>
  </body>
</html>
